<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack五大核心概念</title>
    <link href="/2025/04/01/webpack%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2025/04/01/webpack%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li>入口  </li><li>输出 </li><li>loader        </li><li>插件  </li><li>模式</li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口起点是指示webpack应该从哪个文件开始构建依赖图。入口起点的上下文目录是entry的目录，而entry本身则被解析为一个绝对路径。这个文件是你应用程序的起点。从入口开始，webpack会找出有哪些其他文件和库是和这个文件相依赖的。      </p><p>webpack.config.js  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,          <span class="hljs-comment">//入口语法对象写法，方便扩展，比如多入口</span><br>  &#125;,<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,          <span class="hljs-comment">//入口语法简写版    </span><br>  <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;./path/to/my/entry/file1.js&#x27;</span>, <span class="hljs-string">&#x27;./path/to/my/entry/file2.js&#x27;</span>],          <span class="hljs-comment">//多入口写法</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><p>描述入口的对象可以使用以下属性：    </p><ul><li><code>dependOn</code>: 当前入口所依赖的入口。它们必须在该入口被加载前被加载。    </li><li><code>filename</code>: 用于输出文件的文件名。你可以使用<code>[name]</code>占位符来使用入口名称。    </li><li><code>import</code>: 用于动态导入的模块。    </li><li><code>library</code>: 用于导出库的相关选项。 </li><li><code>runtime</code>: 用于控制运行时代码的选项。     </li><li><code>publicPath</code>: 用于指定输出资源的公共路径。</li></ul><p>webpack.config.js   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">main</span>: &#123;<br>      <span class="hljs-attr">import</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">&#x27;shared&#x27;</span>,                   <span class="hljs-comment">//注意：dependOn不能循环依赖，否则会报错。</span><br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>,<br>      <span class="hljs-attr">library</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;myLibrary&#x27;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;umd&#x27;</span>,<br>      &#125;,<br>      <span class="hljs-attr">runtime</span>: <span class="hljs-string">&#x27;runtime.js&#x27;</span>,                <span class="hljs-comment">//注意，runtime和dependOn不能同时使用，否则会报错。</span><br>      <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/assets/&#x27;</span>,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>用法：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,                  <span class="hljs-comment">// 输出文件的文件名。也可以使用[name]占位符来使用入口名称。 </span><br>    <span class="hljs-comment">//或</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),          <span class="hljs-comment">// 输出文件的目标路径在当前目录下的 dist 文件夹中。</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。webpack只能处理 JavaScript 文件和JSON文件，loader 可以将其他类型的文件转换为 JavaScript 模块。loader 可以将 ES6 代码转换为 ES5 代码，将 Sass 转换为 CSS 等。loader 可以通过配置在 webpack.config.js 文件中的 module.rules 数组中定义。       </p><p>使用loader的步骤：  </p><ol><li>安装loader   <ul><li>使用npm或yarn安装loader：<code>npm install --save-dev &lt;loader&gt;</code></li></ul></li><li>在webpack.config.js文件中配置loader：<ul><li>在module.rules数组中添加一个新的对象，对象中包含test、use、exclude、include等属性。<br>   webpack.config.js      <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">        <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>            <span class="hljs-attr">module</span>: &#123;<br>                <span class="hljs-attr">rules</span>: [<br>                &#123;<br>                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,      <span class="hljs-comment">// 使用正则表达式匹配需要处理的文件。   </span><br>                    <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,        <span class="hljs-comment">// 要使用的loader名称。</span><br>                    <span class="hljs-attr">use</span>: [&#123; <br>                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,         <span class="hljs-comment">//使用多种loader时，使用数组对象形式。</span><br>                    &#125;]<br>                    <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,        <span class="hljs-comment">// 排除不需要处理的文件。</span><br>                    <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),        <span class="hljs-comment">// 包含需要处理的文件。</span><br>                &#125;,<br>                ],<br>            &#125;,<br>        &#125;;  <br>        <span class="hljs-string">``</span><span class="hljs-string">`    </span><br><span class="hljs-string">    - 也可以使用内联的方式，在文件中引入loader。    </span><br><span class="hljs-string">        可以在文件内使用`</span><span class="hljs-keyword">import</span><span class="hljs-string">`语句或任何`</span>与 <span class="hljs-string">&quot;import&quot;</span> 方法同等的引用方式<span class="hljs-string">`中指定 loader。使用`</span>!<span class="hljs-string">`将资源中的 loader 分开。每个部分都会相对于当前目录解析。</span><br><span class="hljs-string">## 插件     </span><br><span class="hljs-string">插件是webpack的支柱功能，插件用于实现loader无法解决的其他事情，webpack提供了许多的插件。    </span><br><span class="hljs-string">用法： </span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="模式（mode）"><a href="#模式（mode）" class="headerlink" title="模式（mode）"></a>模式（mode）</h2><p>提供<code>mode</code>配置选项，告知webpack使用相应模式的内置优化。      </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,          <span class="hljs-comment">//值有：development、production、none。分别对象开发、生产、无。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>五大概念到此结束！！！<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。  </p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法之排序</title>
    <link href="/2025/03/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/03/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hello-algo.com/">Hello 算法</a>       </p><p>以下排序都是升序</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>从第一个元素开始把他插入在比他小的元素后面<br>代码:   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">36</span>,<span class="hljs-number">18</span>]  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;          <span class="hljs-comment">//从第二个元素开始插入排序</span><br>    <span class="hljs-keyword">let</span> j = i-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> temp = arr[i];           <span class="hljs-comment">// 记录当前元素（需要插入的元素）</span><br>    <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;temp)&#123;         <span class="hljs-comment">// 从当前元素开始向前遍历，直到找到比当前元素小的元素，插入到该元素的后面。</span><br>        arr[j+<span class="hljs-number">1</span>] = arr[j];<br>        j--;<br>    &#125;<br>    arr[j+<span class="hljs-number">1</span>] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定性：稳定</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">36</span>,<span class="hljs-number">18</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i;j++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;        <span class="hljs-comment">//升序</span><br>            <span class="hljs-keyword">let</span> temp = arr[j]<br>            arr[j] = arr[j+<span class="hljs-number">1</span>]<br>            arr[j+<span class="hljs-number">1</span>] = temp<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法排序的一趟结果是让最大的元素在最后一位，然后再进行下一趟排序，让第二大的元素在倒数第二位，以此类推。<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定性：稳定    </p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择当前最小的元素放在最前面。<br>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">25</span>,<span class="hljs-number">36</span>,<span class="hljs-number">18</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> minIndex = i<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i+<span class="hljs-number">1</span>;j&lt;arr.<span class="hljs-property">length</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;       <br>            minIndex = j            <span class="hljs-comment">// 记录当前最小元素的索引</span><br>        &#125;       <br>    &#125;<br>    <span class="hljs-keyword">let</span> temp = arr[i]<br>    arr[i] = arr[minIndex]<br>    arr[minIndex] = temp            <span class="hljs-comment">// 交换当前元素和最小元素的位置，从第一个元素开始，每次找到最小元素，放到前面。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定      </p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2025/03/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2025/03/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-正则表达式字符匹配攻略"><a href="#1-正则表达式字符匹配攻略" class="headerlink" title="1. 正则表达式字符匹配攻略"></a>1. 正则表达式字符匹配攻略</h2><h3 id="1-1-两种模糊匹配"><a href="#1-1-两种模糊匹配" class="headerlink" title="1.1 两种模糊匹配"></a>1.1 两种模糊匹配</h3><ul><li>横向模糊匹配</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/ab&#123;1,3&#125;c/g</span>;    <span class="hljs-comment">//第一个查找a，第二个查找1到3个b，第三个查找c。     全局查找</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg));     <br><span class="hljs-comment">// abc abbc abbbc </span><br></code></pre></td></tr></table></figure><ul><li>纵向模糊匹配</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/a[123]c/g</span>;    <span class="hljs-comment">//第一个查找a，第二个查找1或2或3，第三个查找c。     全局查找</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;a1c a2c a3c a4c a5c&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg));     <br><span class="hljs-comment">// a1c a2c a3c </span><br></code></pre></td></tr></table></figure><h3 id="1-2-字符组"><a href="#1-2-字符组" class="headerlink" title="1.2 字符组"></a>1.2 字符组</h3><p>虽然叫字符组，但只是其中的一个字符。<br>例如<code>[abc]</code>，表示匹配一个字符，可以是a或b或c。<br>如果想查找全部大写字母，可以使用<code>[A-Z]</code>。   </p><p>如果是排除某个字符，则可以使用<code>[^abc]</code>。表示排除a，b，c三个字符。    </p><p>当然也有一些简写显示    </p><table><thead><tr><th align="center">简写</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\d</code></td><td align="center">表示[0-9]。表示一位数字</td></tr><tr><td align="center"><code>\D</code></td><td align="center">表示[^0-9]。表示除数字外任意字符</td></tr><tr><td align="center"><code>\w</code></td><td align="center">表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。</td></tr><tr><td align="center"><code>\W</code></td><td align="center">表示 [^0-9a-zA-Z_]。非单词字符。</td></tr><tr><td align="center"><code>\s</code></td><td align="center">表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。</td></tr><tr><td align="center"><code>\S</code></td><td align="center">表示 [^ \t\v\n\r\f]。 非空白符。</td></tr><tr><td align="center"><code>.</code></td><td align="center">所有字符</td></tr></tbody></table><h3 id="1-3-量词"><a href="#1-3-量词" class="headerlink" title="1.3 量词"></a>1.3 量词</h3><p><code>&#123;m,n&#125;</code>表示前面的字符或字符组出现m或n次。       </p><p>简写形式    </p><table><thead><tr><th align="center">简写</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="center">等价于{0,}，表示前面的字符或字符组出现0次或多次。</td></tr><tr><td align="center"><code>+</code></td><td align="center">等价于{1,}，表示前面的字符或字符组出现1次或多次。</td></tr><tr><td align="center"><code>?</code></td><td align="center">等价于{0,1}表，示前面的字符或字符组出现0次或1次。</td></tr><tr><td align="center"><code>&#123;m&#125;</code></td><td align="center">表示前面的字符或字符组出现m次。</td></tr><tr><td align="center"><code>&#123;m,&#125;</code></td><td align="center">表示前面的字符或字符组出现m次或多次。</td></tr></tbody></table><p>例如：RegExp: &#x2F;a{1,2}b{3,}c{4}d?e+f*&#x2F;<br>表示：a字符出现1次或2次，b字符出现3次或多次，c字符出现4次，d字符出现0次或1次，e字符出现1次或多次，f字符出现0次或多次。    </p><h4 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h4><ul><li>贪婪匹配：尽可能多的匹配    </li><li>惰性匹配：尽可能少的匹配</li></ul><p>默认情况下是贪婪匹配，在量词后面加个<code>?</code>就能实现惰性匹配。   </p><h3 id="1-4-多选分支"><a href="#1-4-多选分支" class="headerlink" title="1.4 多选分支"></a>1.4 多选分支</h3><p><code>|</code>表示多选分支，多选分支中的内容，只要匹配一个就可以。<br>例如：RegExp: <code>/abc|def|ghi/ </code><br>表示：匹配abc、def或ghi中的任意一个。<br>多选分支是惰性的，前面的匹配到了，后面的就不再尝试了。  </p><h2 id="2-正则表达式位置匹配攻略"><a href="#2-正则表达式位置匹配攻略" class="headerlink" title="2. 正则表达式位置匹配攻略"></a>2. 正则表达式位置匹配攻略</h2><p>位置的概念：相邻字符之间的位置，包括行头和行尾。位置可以理解为空字符<code>&quot;&quot;</code>            </p><p><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头。<br><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^|$/g</span>;    <br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc a123 a!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-string">&#x27;#&#x27;</span>));  <br><span class="hljs-comment">//  #abc a123 a!#</span><br></code></pre></td></tr></table></figure><p>多行匹配模式<code>m</code>。   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^|$/gm</span>;    <br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc\n a123 a!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-string">&#x27;#&#x27;</span>));  <br><span class="hljs-comment">//  #abc#</span><br><span class="hljs-comment">//  #a123 a!#</span><br></code></pre></td></tr></table></figure><p><code>\b</code>是单词边界，具体就是<code>\w</code>和<code>\W</code>之间的位置。通俗来说就是字符或数字与非字符或数字之间的位置。    </p><p><code>\B</code>就是<code>\b</code>的反义词，非单词边界。      </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\b/g</span>;    <br><span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/\B/g</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;abc a123 a!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-string">&#x27;#&#x27;</span>));  <br><span class="hljs-comment">//  #abc# #a123# #a#!</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg1,<span class="hljs-string">&#x27;#&#x27;</span>)); <br><span class="hljs-comment">//  a#b#c a#1#2#3 a!#     </span><br><span class="hljs-string">``</span><span class="hljs-string">`     </span><br><span class="hljs-string"></span><br><span class="hljs-string">- `</span>(?=p)<span class="hljs-string">`是正向先行断言，具体就是p前面的位置。   </span><br><span class="hljs-string"></span><br><span class="hljs-string">- `</span>(?!p)<span class="hljs-string">`是负向后发断言，是正向先行断言的方面意思。 </span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><span class="hljs-comment">// =&gt; &quot;he#l#lo&quot;</span><br><br><span class="hljs-keyword">var</span> result1 = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?!l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<br><span class="hljs-comment">// =&gt; &quot;#h#ell#o#&quot;</span><br><br></code></pre></td></tr></table></figure><p>案例：数字的千分位分隔符表示法  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;    <br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;1234567890&quot;</span>;    <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-string">&#x27;,&#x27;</span>));  <br><span class="hljs-comment">//  1,234,567,890</span><br></code></pre></td></tr></table></figure><p>解释：<code>^</code>表示匹配开头，<code>(?!^)</code>排除开头的位置，<code>(\d&#123;3&#125;)</code>表示匹配三个数字，<code>?=(\d&#123;3&#125;)</code>表示匹配三个数字前面的位置，<code>+</code>表示匹配三个数字前面的位置1次或多次，<code>$</code>表示匹配结尾，  </p><h2 id="3-正则表达式括号的作用"><a href="#3-正则表达式括号的作用" class="headerlink" title="3. 正则表达式括号的作用"></a>3. 正则表达式括号的作用</h2><p>括号的作用：分组，记忆，截取。    </p><ul><li>分组  </li><li>分支结构</li></ul><p>替换<br>想把日期的yyyy-mm-dd格式替换成mm&#x2F;dd&#x2F;yyyy格式，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>;    <br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;2020-01-01&quot;</span>;    <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg));  <br><span class="hljs-comment">//  [&quot;2020-01-01&quot;, &quot;2020&quot;, &quot;01&quot;, &quot;01&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;$2/$3/$1&#x27;</span>));  <br><span class="hljs-comment">//  01/01/2020</span><br></code></pre></td></tr></table></figure><p>replace中的第二个参数里用$1、$2、$3表示分组捕获的内容。    </p><p>反向引用<br><code>\1</code>表示第一个分组捕获的内容，<code>\2</code>表示第二个分组捕获的内容。<br>如果遇到嵌套的括号，则从外内里分组，从左到右分组。    </p><p>如果引用了不存在的分组，不会报错，只是匹配反向引用字符本身。    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dify本地部署遇到的问题</title>
    <link href="/2025/03/24/dify%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/03/24/dify%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dify本地部署遇到的问题"><a href="#dify本地部署遇到的问题" class="headerlink" title="dify本地部署遇到的问题"></a>dify本地部署遇到的问题</h1><blockquote><p>最近在学习dify，准备在本地部署一下，但是遇到了一些问题，记录一下。<a href="https://docs.dify.ai/zh-hans/getting-started/install-self-hosted/docker-compose">docker compose部署</a>       </p></blockquote><h2 id="1-启动报错"><a href="#1-启动报错" class="headerlink" title="1. 启动报错"></a>1. 启动报错</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># v2</span><br>docker compose up -d    <br><span class="hljs-comment"># or</span><br><span class="hljs-comment"># v1</span><br>docker-compose up -d     <br><span class="hljs-comment"># 判断v1还是v2   </span><br>docker compose version<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:80 -&gt; 127.0.0.1:0: listen tcp 0.0.0.0:80: <span class="hljs-built_in">bind</span>: An attempt was made to access a socket <span class="hljs-keyword">in</span> a way forbidden by its access permissions.<br></code></pre></td></tr></table></figure><p>出现这个问题是因为端口被占用了，需要修改端口号。<br>dify&#x2F;docker&#x2F;.env文件中修改端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 80改为8081</span><br>EXPOSE_NGINX_PORT=8081<br></code></pre></td></tr></table></figure><p>重新启动docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose down<br>docker compose up -d<br></code></pre></td></tr></table></figure><p>就可以看到和文档中一样的效果了。<br>接着访问 <a href="http://localhost:8081/">http://localhost:8081</a>  就可以看到dify的首页了。</p><h2 id="2-本地启动web项目报错"><a href="#2-本地启动web项目报错" class="headerlink" title="2. 本地启动web项目报错"></a>2. 本地启动web项目报错</h2><p>dify&#x2F;web文件夹下启动web项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>报错：<br><img src="/img/post/image.png" alt="alt text"><br>这个时候就要修改web项目的端口号了<br>dify&#x2F;web&#x2F;.env.local文件中修改端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 改成和上一个问题中一样的端口号</span><br>NEXT_PUBLIC_API_PREFIX=http://localhost:8081/console/api<br>NEXT_PUBLIC_PUBLIC_API_PREFIX=http://localhost:8081/api<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每天学习一个插件之tailwind merge</title>
    <link href="/2025/03/21/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%B9%8Btailwind-merge/"/>
    <url>/2025/03/21/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%B9%8Btailwind-merge/</url>
    
    <content type="html"><![CDATA[<h1 id="每天学习一个插件之tailwind-merge"><a href="#每天学习一个插件之tailwind-merge" class="headerlink" title="每天学习一个插件之tailwind-merge"></a>每天学习一个插件之tailwind-merge</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>tailwind-merge是一个用于合并tailwind类名的工具。它可以将多个类名合并成一个，从而减少代码量，提高开发效率。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install tailwind-merge<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; twMerge &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tailwind-merge&#x27;</span>;   <br><span class="hljs-keyword">const</span> mergedClassName = <span class="hljs-title function_">twMerge</span>(<span class="hljs-string">&#x27;text-red-500 bg-blue-100&#x27;</span>, <span class="hljs-string">&#x27;text-green-500 bg-yellow-100&#x27;</span>);    <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mergedClassName); <span class="hljs-comment">// 输出：&#x27;text-green-500 bg-yellow-100&#x27;   简单来说：后来者居上</span><br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tailwind-merge的原理是将多个类名按照优先级进行排序，然后按照顺序进行合并。具体来说，tailwind-merge会将类名按照以下顺序进行排序：</p><ol><li>基础类名：例如text-red-500、bg-blue-100等。</li><li>变体类名：例如hover:text-red-500、focus:bg-blue-100等。</li><li>响应式类名：例如md:text-red-500、lg:bg-blue-100等。</li><li>自定义类名：例如text-red-500、bg-blue-100等。<br>然后，tailwind-merge会按照顺序进行合并，最终得到一个合并后的类名。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript异步操作</title>
    <link href="/2025/02/13/JavaScript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/02/13/JavaScript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步操作"><a href="#JavaScript异步操作" class="headerlink" title="JavaScript异步操作"></a>JavaScript异步操作</h1><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="异步操作的概念"><a href="#异步操作的概念" class="headerlink" title="异步操作的概念"></a>异步操作的概念</h3><p>异步操作是指在程序执行过程中，某些操作的执行时间不确定，可能会在未来的某个时间点完成。异步操作通常是通过回调函数或Promise对象来处理的。</p><h3 id="异步操作的优点"><a href="#异步操作的优点" class="headerlink" title="异步操作的优点"></a>异步操作的优点</h3><p>异步操作的优点包括：</p><ol><li>提高程序的响应速度：异步操作可以在后台执行，不会阻塞主线程，从而提高程序的响应速度。</li><li>避免阻塞主线程：异步操作可以在后台执行，不会阻塞主线程，从而避免了阻塞主线程的问题。</li><li>简化代码：异步操作可以通过回调函数或Promise对象来处理，从而简化了代码。</li></ol><h3 id="异步操作的缺点"><a href="#异步操作的缺点" class="headerlink" title="异步操作的缺点"></a>异步操作的缺点</h3><p>异步操作的缺点包括：</p><ol><li>代码可读性差：异步操作的代码可读性差，需要使用回调函数或Promise对象来处理，从而导致代码可读性差。</li><li>代码复杂度高：异步操作的代码复杂度高，需要使用回调函数或Promise对象来处理，从而导致代码复杂度高。</li><li>错误处理困难：异步操作的错误处理困难，需要使用回调函数或Promise对象来处理，从而导致错误处理困难。</li></ol><h3 id="异步操作的使用场景"><a href="#异步操作的使用场景" class="headerlink" title="异步操作的使用场景"></a>异步操作的使用场景</h3><p>异步操作的使用场景包括：</p><ol><li>网络请求：异步操作可以用于网络请求，例如Ajax请求。</li><li>文件操作：异步操作可以用于文件操作，例如读取文件。</li><li>定时器：异步操作可以用于定时器，例如setTimeout和setInterval。</li><li>事件监听：异步操作可以用于事件监听，例如addEventListener。</li></ol><h3 id="异步操作的实现方式"><a href="#异步操作的实现方式" class="headerlink" title="异步操作的实现方式"></a>异步操作的实现方式</h3><p>异步操作的实现方式包括：</p><ol><li>回调函数：回调函数是异步操作的实现方式之一，通过回调函数来处理异步操作的结果。</li><li>Promise对象：Promise对象是异步操作的实现方式之一，通过Promise对象来处理异步操作的结果。  </li><li>async&#x2F;await：async&#x2F;await是异步操作的实现方式之一，通过async&#x2F;await来处理异步操作的结果。  </li><li>Generator函数：Generator函数是异步操作的实现方式之一，通过Generator函数来处理异步操作的结果。</li></ol><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是一个函数作为参数传递给另一个函数，当这个函数执行完后，再执行回调函数。<br>回调函数的缺点：厄运金字塔  </p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//异步操作</span><br>    <span class="hljs-keyword">if</span>(异步操作成功)&#123;<br>        <span class="hljs-title function_">resolve</span>(value);<br>    &#125;<br>&#125;)<br><span class="hljs-string">``</span><span class="hljs-string">`     </span><br><span class="hljs-string">上面是promise构造器的语法，传递给new Promise的函数叫做执行器。当new Promise创建时，执行器会立即执行。  </span><br><span class="hljs-string">执行器(executor)函数接收两个参数：resolve和reject。都是JavaScript自身提供的函数。       </span><br><span class="hljs-string">当executor函数获取结果后，都应该调用resolve或reject函数。   </span><br><span class="hljs-string">- resolve(value)：异步操作成功时调用，将异步操作的结果作为参数传递出去。</span><br><span class="hljs-string">- reject(error)：异步操作失败时调用，将异步操作的错误作为参数传递出去。         </span><br><span class="hljs-string"></span><br><span class="hljs-string">由new Promise创建的对象promise对象具有以下内部属性：        </span><br><span class="hljs-string">- [[PromiseState]]：Promise对象的状态，有三种可能的值：pending、fulfilled、rejected。</span><br><span class="hljs-string">- [[PromiseResult]]：Promise对象的结果，初始值为undefined。 </span><br><span class="hljs-string">以上属性在调用resolve(value)的时候结果变为value，状态变为fulfilled  </span><br><span class="hljs-string">在调用reject(error)的时候结果变为error，状态变为rejected。      </span><br><span class="hljs-string">      </span><br><span class="hljs-string">executor只能执行一次resolve或者reject函数，后面的都会被忽略。同样reslove和reject函数只接收一个参数，其余参数都会被忽略。    </span><br><span class="hljs-string"></span><br><span class="hljs-string">1. then()、catch()      </span><br><span class="hljs-string">怎么对对象的状态和结果进行操作呢？这就需要then()和catch()方法了。       </span><br><span class="hljs-string">- then方法接收两个函数作为参数，第一个函数是Promise对象的状态变为fulfilled时调用，第二个函数是Promise对象的状态变为rejected时调用。         </span><br><span class="hljs-string">- 只对fulfilled感兴趣的话，可以只传入一个函数作为参数，第二个函数可以省略。`</span><span class="hljs-title function_">then</span>(<span class="hljs-title function_">resolve</span>()=&gt;&#123;&#125;)<span class="hljs-string">`。</span><br><span class="hljs-string">- 只对rejected感兴趣的话，可以使用catch方法。`</span><span class="hljs-keyword">catch</span>(<span class="hljs-title function_">reject</span>()=&gt;&#123;&#125;)<span class="hljs-string">`。`</span><span class="hljs-keyword">catch</span>(f)<span class="hljs-string">`相当于`</span><span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,f)<span class="hljs-string">`。        </span><br><span class="hljs-string"></span><br><span class="hljs-string">2. finlly() </span><br><span class="hljs-string">finnly()方法用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是ES2018引入的标准。就像一个清洁工。 </span><br><span class="hljs-string"></span><br><span class="hljs-string">实例：</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-comment">//加载脚本的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) &#123;<br>  <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  script.<span class="hljs-property">src</span> = src;<br><br>  script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, script);<br>  script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">$&#123;src&#125;</span>`</span>));<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用Promise的写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-property">src</span> = src;<br>    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(script);<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">$&#123;src&#125;</span>`</span>));<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//用法  </span><br><span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;</span>);<br><br>promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;script.src&#125;</span> is loaded!`</span>),<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>)<br>);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Another handler...&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h3><p>Promise的链式调用是指在一个Promise对象的then方法中返回另一个Promise对象，然后再在这个Promise对象的then方法中返回另一个Promise对象，以此类推，直到返回一个非Promise对象。这样可以将多个异步操作串联起来，实现更复杂的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//链式调用</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>); <span class="hljs-comment">// (*)</span><br><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123; <span class="hljs-comment">// (**)</span><br><br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123; <span class="hljs-comment">// (***)</span><br><br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br><br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 4</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>另外，将多个then加到promise上面不是链式调用，而是并行调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br>&#125;)  <br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>promise的处理程序.then、.catch、.finally都是异步的。  </p><h3 id="使用promise进行错误处理"><a href="#使用promise进行错误处理" class="headerlink" title="使用promise进行错误处理"></a>使用promise进行错误处理</h3><p>promise链在错误处理中十分强大，捕获所有错误的最简单的方法是，将.catch()加到链尾。</p><ul><li>隐性try…catch<br>  promise的执行器和then&#x2F;catch中的代码都会被try…catch包裹。如果发生异常，会被catch捕获，并被视为reject进行处理。   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(alert); <span class="hljs-comment">// Error: Whoops!</span><br><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>));<br>&#125;).<span class="hljs-title function_">catch</span>(alert); <span class="hljs-comment">// Error: Whoops!</span><br></code></pre></td></tr></table></figure>  以上两种写法效果相同。</li></ul><p>如果promise出现了错误，被catch捕获，但是catch里面也出现了错误，那么就会被下一个catch捕获。这叫再次抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);<br>&#125;)      <br>.<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;The error is handled, continue normally&quot;</span>); <span class="hljs-comment">// 错误被捕获，继续正常执行</span><br>  <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 再次抛出错误      </span><br>&#125;)  <br>.<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`The second error handler is also executed: <span class="hljs-subst">$&#123;error&#125;</span>`</span>); <span class="hljs-comment">// 错误被捕获，继续正常执行         </span><br>&#125;)  <br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>all()<br>  等待所有的promise都被resolve，才会返回结果。     </li><li>allSettled()<br>  等待所有的promise都被resolve或reject，才会返回结果。</li><li>any()<br>  只要有一个promise被resolve，就会返回结果。</li><li>race()<br>  只要有一个promise被resolve或reject，就会返回结果。</li><li>resolve()<br>  用结果值value创建一个resolved的promise对象。</li><li>reject()<br>  用结果值reason创建一个rejected的promise对象。</li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>async&#x2F;await是基于promise的语法糖。<br>async放在函数前面，表示该函数始终返回promise，其他值将自动被包装在一个resolved的promise中。<br>await只能放在async函数中。让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。期间引擎会去执行其他任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;   <br><span class="hljs-string">``</span><span class="hljs-string">`   </span><br><span class="hljs-string">等同于：</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`   </span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;done!&quot;</span>), <span class="hljs-number">1000</span>)<br>  &#125;);   <br>  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> promise; <span class="hljs-comment">// 等待promise完成并返回结果</span><br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// &quot;done!&quot;     过一秒后才会执行改语句</span><br>&#125; <br><span class="hljs-string">``</span><span class="hljs-string">`   </span><br><span class="hljs-string">当出现错误时，会抛出异常，需要使用try...catch来捕获。</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/no-user-here&#x27;</span>);<br>    <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    <span class="hljs-comment">// 捕获到 fetch 和 response.json 中的错误</span><br>    <span class="hljs-title function_">alert</span>(err);<br>  &#125;<br>&#125; <br><span class="hljs-title function_">f</span>();<br><span class="hljs-string">``</span><span class="hljs-string">`   </span><br><span class="hljs-string">如果有error发生，执行控制权会交到catch块。如果没有try...catch，error会被抛出。</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/no-user-here&#x27;</span>);<br>  <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 这里会报错</span><br>&#125; <br><span class="hljs-title function_">f</span>();    <br><span class="hljs-comment">// 可以使用.catch()来捕获error</span><br><span class="hljs-title function_">f</span>().<span class="hljs-title function_">catch</span>(alert);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript高级程序设计(第4版)-第三章</title>
    <link href="/2025/02/10/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC4%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2025/02/10/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC4%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章语言基础"><a href="#第三章语言基础" class="headerlink" title="第三章语言基础"></a>第三章语言基础</h1><span id="more"></span><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><!-- <div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div> --><p>略</p><h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2 关键字与保留字"></a>3.2 关键字与保留字</h2><p>略</p><h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h2><h3 id="3-3-1-var关键字"><a href="#3-3-1-var关键字" class="headerlink" title="3.3.1 var关键字"></a>3.3.1 var关键字</h3><ol><li><p>var声明作用域<br>声明范围：函数作用域    </p></li><li><p>var声明提升<br>所谓的“提升”（hoist），就是把所有变量声明都拉到函数作用域的顶部。意思是可以先用后付。   </p><pre><code class="hljs"> 现在不太推荐使用var声明变量，因为容易造成全局变量污染</code></pre></li></ol><h3 id="3-3-2-let关键字"><a href="#3-3-2-let关键字" class="headerlink" title="3.3.2 let关键字"></a>3.3.2 let关键字</h3><ol><li>let声明作用域<br>声明范围：块级作用域<br>这里是和var定义变量不同的地方，块级作用域是函数作用域的子集。 </li><li>let声明不可重复<br>这也是和var定义变量不同的地方，let声明的变量，在同一作用域内不能重复声明。不然会报语法错误。</li><li>let声明暂时性死区</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;lisa&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);    <span class="hljs-comment">//lisa</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);    <span class="hljs-comment">//ReferenceError: age is not defined</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">22</span>;<br></code></pre></td></tr></table></figure><p>在age被声明之前引用了age造成了“暂时性死区”。造成这个的原因是let声明的变量不会提升。在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出ReferenceError。    </p><ol start="4"><li>for循环中的let声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">//5 5 5 5 5</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">//0 1 2 3 4</span><br></code></pre></td></tr></table></figure><p>原因：for循环是同步的，setTimeout是异步的，涉及到宏任务和微任务。在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><h3 id="3-3-3-const关键字"><a href="#3-3-3-const关键字" class="headerlink" title="3.3.3 const关键字"></a>3.3.3 const关键字</h3><ol><li>const声明变量和let声明变量差不多。不同的是，const声明变量时必须初始化，且声明的变量不能被修改。<br>如果const声明的是对象，可以修改对象的属性值。</li></ol><h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><ul><li>数值（number）  </li><li>字符串（string）  </li><li>布尔值（boolean）  </li><li>null（null）  </li><li>undefined（undefined）  </li><li>Symbol（ES6新增）</li></ul><h3 id="3-4-1-undefined"><a href="#3-4-1-undefined" class="headerlink" title="3.4.1 undefined"></a>3.4.1 undefined</h3><p>   undefined也是属于变量的值。变量声明了但是没有初始化，那么变量的值就是undefined。永远不必显式地将变量值设置为 undefined，因为本来就是undefined。  </p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">//no!!</span><br> <span class="hljs-keyword">if</span>(<span class="hljs-literal">undefined</span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">if</span>(!<span class="hljs-literal">undefined</span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br> &#125;<br> <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="3-4-2-null"><a href="#3-4-2-null" class="headerlink" title="3.4.2 null"></a>3.4.2 null</h3><p>   null是空对象指针，表示一个空对象。所以使用typeof判断的时候，null会返回object。</p><h3 id="3-4-3-boolean"><a href="#3-4-3-boolean" class="headerlink" title="3.4.3 boolean"></a>3.4.3 boolean</h3><p>   布尔值只有两个值：true和false。false&#x3D;&#x3D;0，true&#x3D;&#x3D;1。<br>   想要把其他数据类型转换为Boolean，使用Boolean()特定函数即可。 </p><h3 id="3-4-4-number"><a href="#3-4-4-number" class="headerlink" title="3.4.4 number"></a>3.4.4 number</h3><p>Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）</p><ol><li><p>浮点数 </p></li><li><p>整数</p></li></ol><p>特殊的数值NaN（Not a Number）不是数值，，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><p>数值转换    </p><ul><li>Number()  适用于任何数据类型   </li><li>parseInt()  适用于字符串  </li><li>parseFloat()  适用于字符串<br>Number()转换规则    </li><li>true为1，false为0。   </li><li>null为0。   </li><li>undefined为NaN。   </li><li>字符串转换规则   <ul><li><p>如果是纯数字，直接转换成十进制数值。   </p></li><li><p>如果是科学计数法，转换成相应的科学计数法表示。   </p></li><li><p>如果是十六进制，转换成相应的十进制数值。   </p></li><li><p>如果是空字符串，转换成0。   </p></li><li><p>如果是非以上格式的字符串，转换成NaN。          </p><p>   TIPS：在数字字符串前面加上加号，也可以将字符串转换为数字。</p></li></ul></li></ul><h3 id="3-4-5-string"><a href="#3-4-5-string" class="headerlink" title="3.4.5 string"></a>3.4.5 string</h3><p>模板字面量<br>JavaScript常常会发生以下情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-comment">//23</span><br></code></pre></td></tr></table></figure><p>原因是因为在JavaScript中，<code>+</code>不仅仅是数字加，也会用来字符相加。         </p><p>特殊字符    </p><table><thead><tr><th align="center">转义序列</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\\</td><td align="center">反斜杠</td></tr><tr><td align="center">\xnn</td><td align="center">十六进制</td></tr><tr><td align="center">\unnnn</td><td align="center">Unicode</td></tr></tbody></table><h3 id="3-4-6-symbol（符号）"><a href="#3-4-6-symbol（符号）" class="headerlink" title="3.4.6 symbol（符号）"></a>3.4.6 symbol（符号）</h3><p>符号是原始值，且符号实例是唯一、不可变的。<br>symbol的基本使用    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>();    <span class="hljs-comment">//使用symbol函数初始化</span><br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)   <span class="hljs-comment">//传入一个字符串作为描述</span><br><br></code></pre></td></tr></table></figure><p>使用场景：</p><ul><li>定义常量 比如圆周率等</li><li>定义私有属性 因为symbol值作为属性名，不会被常规方法遍历到，因此可以用来定义私有属性。</li></ul><h3 id="3-5-引用数据类型"><a href="#3-5-引用数据类型" class="headerlink" title="3.5 引用数据类型"></a>3.5 引用数据类型</h3><ul><li>对象（object）  </li><li>数组（array）  </li><li>函数（function）</li></ul><h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><ol><li>typeof  </li><li>instanceof  </li><li>constructor  </li><li>Object.prototype.toString.call()</li></ol><h2 id="3-6流控制语句"><a href="#3-6流控制语句" class="headerlink" title="3.6流控制语句"></a>3.6流控制语句</h2><ol><li>for-in和for-of的区别<br>for-in循环遍历对象的可枚举属性，for-of循环遍历数组的元素。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
