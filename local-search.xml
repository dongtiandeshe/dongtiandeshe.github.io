<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript异步操作</title>
    <link href="/2025/02/13/JavaScript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/02/13/JavaScript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript异步操作"><a href="#JavaScript异步操作" class="headerlink" title="JavaScript异步操作"></a>JavaScript异步操作</h1><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="异步操作的概念"><a href="#异步操作的概念" class="headerlink" title="异步操作的概念"></a>异步操作的概念</h3><p>异步操作是指在程序执行过程中，某些操作的执行时间不确定，可能会在未来的某个时间点完成。异步操作通常是通过回调函数或Promise对象来处理的。</p><h3 id="异步操作的优点"><a href="#异步操作的优点" class="headerlink" title="异步操作的优点"></a>异步操作的优点</h3><p>异步操作的优点包括：</p><ol><li>提高程序的响应速度：异步操作可以在后台执行，不会阻塞主线程，从而提高程序的响应速度。</li><li>避免阻塞主线程：异步操作可以在后台执行，不会阻塞主线程，从而避免了阻塞主线程的问题。</li><li>简化代码：异步操作可以通过回调函数或Promise对象来处理，从而简化了代码。</li></ol><h3 id="异步操作的缺点"><a href="#异步操作的缺点" class="headerlink" title="异步操作的缺点"></a>异步操作的缺点</h3><p>异步操作的缺点包括：</p><ol><li>代码可读性差：异步操作的代码可读性差，需要使用回调函数或Promise对象来处理，从而导致代码可读性差。</li><li>代码复杂度高：异步操作的代码复杂度高，需要使用回调函数或Promise对象来处理，从而导致代码复杂度高。</li><li>错误处理困难：异步操作的错误处理困难，需要使用回调函数或Promise对象来处理，从而导致错误处理困难。</li></ol><h3 id="异步操作的使用场景"><a href="#异步操作的使用场景" class="headerlink" title="异步操作的使用场景"></a>异步操作的使用场景</h3><p>异步操作的使用场景包括：</p><ol><li>网络请求：异步操作可以用于网络请求，例如Ajax请求。</li><li>文件操作：异步操作可以用于文件操作，例如读取文件。</li><li>定时器：异步操作可以用于定时器，例如setTimeout和setInterval。</li><li>事件监听：异步操作可以用于事件监听，例如addEventListener。</li></ol><h3 id="异步操作的实现方式"><a href="#异步操作的实现方式" class="headerlink" title="异步操作的实现方式"></a>异步操作的实现方式</h3><p>异步操作的实现方式包括：</p><ol><li>回调函数：回调函数是异步操作的实现方式之一，通过回调函数来处理异步操作的结果。</li><li>Promise对象：Promise对象是异步操作的实现方式之一，通过Promise对象来处理异步操作的结果。  </li><li>async&#x2F;await：async&#x2F;await是异步操作的实现方式之一，通过async&#x2F;await来处理异步操作的结果。  </li><li>Generator函数：Generator函数是异步操作的实现方式之一，通过Generator函数来处理异步操作的结果。</li></ol><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是一个函数作为参数传递给另一个函数，当这个函数执行完后，再执行回调函数。<br>回调函数的缺点：厄运金字塔  </p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//异步操作</span><br>    <span class="hljs-keyword">if</span>(异步操作成功)&#123;<br>        <span class="hljs-title function_">resolve</span>(value);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript高级程序设计(第4版)-第三章</title>
    <link href="/2025/02/10/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC4%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2025/02/10/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC4%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章语言基础"><a href="#第三章语言基础" class="headerlink" title="第三章语言基础"></a>第三章语言基础</h1><span id="more"></span><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><!-- <div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div> --><p>略</p><h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2 关键字与保留字"></a>3.2 关键字与保留字</h2><p>略</p><h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h2><h3 id="3-3-1-var关键字"><a href="#3-3-1-var关键字" class="headerlink" title="3.3.1 var关键字"></a>3.3.1 var关键字</h3><ol><li><p>var声明作用域<br>声明范围：函数作用域    </p></li><li><p>var声明提升<br>所谓的“提升”（hoist），就是把所有变量声明都拉到函数作用域的顶部。意思是可以先用后付。   </p><pre><code class="hljs"> 现在不太推荐使用var声明变量，因为容易造成全局变量污染</code></pre></li></ol><h3 id="3-3-2-let关键字"><a href="#3-3-2-let关键字" class="headerlink" title="3.3.2 let关键字"></a>3.3.2 let关键字</h3><ol><li>let声明作用域<br>声明范围：块级作用域<br>这里是和var定义变量不同的地方，块级作用域是函数作用域的子集。 </li><li>let声明不可重复<br>这也是和var定义变量不同的地方，let声明的变量，在同一作用域内不能重复声明。不然会报语法错误。</li><li>let声明暂时性死区</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;lisa&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);    <span class="hljs-comment">//lisa</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);    <span class="hljs-comment">//ReferenceError: age is not defined</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">22</span>;<br></code></pre></td></tr></table></figure><p>在age被声明之前引用了age造成了“暂时性死区”。造成这个的原因是let声明的变量不会提升。在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出ReferenceError。    </p><ol start="4"><li>for循环中的let声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">//5 5 5 5 5</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">//0 1 2 3 4</span><br></code></pre></td></tr></table></figure><p>原因：for循环是同步的，setTimeout是异步的，涉及到宏任务和微任务。在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><h3 id="3-3-3-const关键字"><a href="#3-3-3-const关键字" class="headerlink" title="3.3.3 const关键字"></a>3.3.3 const关键字</h3><ol><li>const声明变量和let声明变量差不多。不同的是，const声明变量时必须初始化，且声明的变量不能被修改。<br>如果const声明的是对象，可以修改对象的属性值。</li></ol><h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><ul><li>数值（number）  </li><li>字符串（string）  </li><li>布尔值（boolean）  </li><li>null（null）  </li><li>undefined（undefined）  </li><li>Symbol（ES6新增）</li></ul><h3 id="3-4-1-undefined"><a href="#3-4-1-undefined" class="headerlink" title="3.4.1 undefined"></a>3.4.1 undefined</h3><p>   undefined也是属于变量的值。变量声明了但是没有初始化，那么变量的值就是undefined。永远不必显式地将变量值设置为 undefined，因为本来就是undefined。  </p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">//no!!</span><br> <span class="hljs-keyword">if</span>(<span class="hljs-literal">undefined</span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">if</span>(!<span class="hljs-literal">undefined</span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br> &#125;<br> <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="3-4-2-null"><a href="#3-4-2-null" class="headerlink" title="3.4.2 null"></a>3.4.2 null</h3><p>   null是空对象指针，表示一个空对象。所以使用typeof判断的时候，null会返回object。</p><h3 id="3-4-3-boolean"><a href="#3-4-3-boolean" class="headerlink" title="3.4.3 boolean"></a>3.4.3 boolean</h3><p>   布尔值只有两个值：true和false。false&#x3D;&#x3D;0，true&#x3D;&#x3D;1。<br>   想要把其他数据类型转换为Boolean，使用Boolean()特定函数即可。 </p><h3 id="3-4-4-number"><a href="#3-4-4-number" class="headerlink" title="3.4.4 number"></a>3.4.4 number</h3><p>Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）</p><ol><li><p>浮点数 </p></li><li><p>整数</p></li></ol><p>特殊的数值NaN（Not a Number）不是数值，，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><p>数值转换    </p><ul><li>Number()  适用于任何数据类型   </li><li>parseInt()  适用于字符串  </li><li>parseFloat()  适用于字符串<br>Number()转换规则    </li><li>true为1，false为0。   </li><li>null为0。   </li><li>undefined为NaN。   </li><li>字符串转换规则   <ul><li><p>如果是纯数字，直接转换成十进制数值。   </p></li><li><p>如果是科学计数法，转换成相应的科学计数法表示。   </p></li><li><p>如果是十六进制，转换成相应的十进制数值。   </p></li><li><p>如果是空字符串，转换成0。   </p></li><li><p>如果是非以上格式的字符串，转换成NaN。          </p><p>   TIPS：在数字字符串前面加上加号，也可以将字符串转换为数字。</p></li></ul></li></ul><h3 id="3-4-5-string"><a href="#3-4-5-string" class="headerlink" title="3.4.5 string"></a>3.4.5 string</h3><p>模板字面量<br>JavaScript常常会发生以下情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-comment">//23</span><br></code></pre></td></tr></table></figure><p>原因是因为在JavaScript中，<code>+</code>不仅仅是数字加，也会用来字符相加。         </p><p>特殊字符    </p><table><thead><tr><th align="center">转义序列</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\\</td><td align="center">反斜杠</td></tr><tr><td align="center">\xnn</td><td align="center">十六进制</td></tr><tr><td align="center">\unnnn</td><td align="center">Unicode</td></tr></tbody></table><h3 id="3-4-6-symbol（符号）"><a href="#3-4-6-symbol（符号）" class="headerlink" title="3.4.6 symbol（符号）"></a>3.4.6 symbol（符号）</h3><p>符号是原始值，且符号实例是唯一、不可变的。<br>symbol的基本使用    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>();    <span class="hljs-comment">//使用symbol函数初始化</span><br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)   <span class="hljs-comment">//传入一个字符串作为描述</span><br><br></code></pre></td></tr></table></figure><p>使用场景：</p><ul><li>定义常量 比如圆周率等</li><li>定义私有属性 因为symbol值作为属性名，不会被常规方法遍历到，因此可以用来定义私有属性。</li></ul><h3 id="3-5-引用数据类型"><a href="#3-5-引用数据类型" class="headerlink" title="3.5 引用数据类型"></a>3.5 引用数据类型</h3><ul><li>对象（object）  </li><li>数组（array）  </li><li>函数（function）</li></ul><h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><ol><li>typeof  </li><li>instanceof  </li><li>constructor  </li><li>Object.prototype.toString.call()</li></ol><h2 id="3-6流控制语句"><a href="#3-6流控制语句" class="headerlink" title="3.6流控制语句"></a>3.6流控制语句</h2><ol><li>for-in和for-of的区别<br>for-in循环遍历对象的可枚举属性，for-of循环遍历数组的元素。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
